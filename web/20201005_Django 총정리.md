### Django 정리

- 명령어중 -s붙이는거 (makemigrations)

- `render()`의 세번째 인자로 `{'key': value}` 와 같이 딕셔너리 형태로 넘겨주며, 여기서 정의한 `key`에 해당하는 문자열이 template에서 사용 가능한 변수명이 된다.

- 동적라우팅(Variable Routing): 주소 자체를 변수처럼 사용해서 동적으로 주소를 만드는것

  - default는 `str` 이기 때문에 생략 가능하다.

  ```python
  # first_project/urls.py
  
  urlpatterns = [
      ... ,
      # 혹은 path('hello/<name>/', views.hello),
      path('hello/<str:name>/', views.hello),
  ]
  ```

  ```python
  # articles/views.py
  
  def hello(request, name):
      context = {
          'name': name,
      }
      return render(request, 'hello.html', context)
  ```

  ```html
  <!-- articles/templates/hello.html -->
  
  <h1>안녕하세요, {{ name }}님!</h1>
  ```

- url 분리

- - 다른 URLconf(app1/urls.py)들을 참조할 수 있도록 도와준다.

  - Django가 함수 `include()`를 만나게 되면, URL의 그 시점까지 일치하는 부분을 잘라내고, 남은 문자열 부분을 후속 처리를 위해 include 된 URLconf로 전달한다.

  ```python
  # firstapp/urls.py
  
  from django.urls import path, include
  
  
  urlpatterns = [
      path('admin/', admin.site.urls),
      path('articles/', include('articles.urls')),
      path('pages/', include('pages.urls')),
  ]
  ```

  

- URL Name

  - path() 함수의 name value를 작성해 `{% url %}` template tag로 호출

  - **url template tag** : django 는 path() 함수에서 name 인수(optional) 를 정의해, `{% url %}` template tag 를 사용하여 URL 설정에 정의된 특정한 URL 경로들의 의존성을 제거할 수 있다.

    `  <form action="{% url 'catch' %}" method="GET">`

- URL Namespace

  - 예를 들어, articles app은 index 이라는 view를 가지고 있고, 동일한 프로젝트에 다른 app 에서도 index 이라는 view를 가지고 동일한 url name 을 사용할 수도 있다. 과연 Django가 `{% url 'index' %}` 처럼 사용할 때, 어떤 app 의 view 에서 URL을 생성할지 알 수 있을까?

  - urls.py 에 app_name 을 통해 app 의 이름공간을 설정한다.

    `app_name = 'articles'`

  - 이제 기존 모든 url 은 다음과 같이 변경할 수 있다.

    `<form action="{% url 'articles:catch' %}" method="GET">`

- Template Inheritance

  - `base.html` 파일을 `firstapp/templates/base.html` 에 생성 해보자.

  - Django는 기본적으로 `app_name/templates` 를 바라보게 설정되어있다. (`APP_DIRS=True` 설정)

  - 우리가 옮긴 위치는 `project폴더/templates` 이므로, Django는 현재 상태에서 해당 template 파일을 찾을 수 없다.

  - 각 앱 내의 `templates` 폴더가 아닌 임의의 위치에 있는 template을 읽기 위해서는 Django에서 그 위치를 알려줘야 한다

    ```python
    TEMPLATES = [
        {
            'BACKEND': 'django.template.backends.django.DjangoTemplates',
            'DIRS': [BASE_DIR / 'first_project' / 'templates'],
            ...,
    ]
    ```

    

- django 설계철학: 표현과 로직을 분리 ,중복을 배제(템플릿 상속)

---



- Model

  **Model 중요 3단계**

  - `models.py` : 변경사항 발생 (생성 / 수정)
  - `makemigrations` : migration 파일 만들기 (설계도)
  - `migrate` : DB에 적용 (테이블 생성)

---



- 테이블 (Table) / 관계(Relation)

  - 필드(field): 속성, 컬럼(Column)

    - 모델 안에 정의한 클래스에서 클래스 변수가 필드가 된다.

  - 레코드(record): 튜플, 행(Row)

    - 우리가 ORM을 통해 해당하는 필드에 넣은 데이터(값)을 의미한다.

- ORM

  - "Object-Relational-Mapping 은 객체 지향 프로그래밍 언어를 사용하여 호환되지 않는 유형의 시스템간에(Django - SQL)데이터를 변환하는 프로그래밍 기술이다. 이것은 프로그래밍 언어에서 사용할 수 있는 '가상 객체 데이터베이스'를 만들어 사용한다."
  - OOP 프로그래밍에서 RDBMS을 연동할 때, 데이터베이스와 객체 지향 프로그래밍 언어 간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법이다. 객체 관계 매핑이라고도 부른다.
  - 객체 지향 언어에서 사용할 수 있는 '가상' 객체 데이터베이스를 구축하는 방법이다.
  - 현대 대부분의 프레임워크는 ORM 사용

- **"우리는 DB를 객체(object)로 조작하기 위해 ORM을 사용한다."**

- 대표필드

  - TextField

    - 글의 수가 많을 때 사용, 기본 양식 위젯은 **Textarera**

    - max_length 옵션을 주면 자동양식필드의 textarea 위젯에 반영은 되지만 모델과 데이터베이스 수준에는 적용되지 않는다. (CharField 를 사용)

  - charfield

    - 기본 양식 위젯은 **TextInput**
    - **필드의 최대 길이(문자),** 데이터베이스 레벨과 Django의 유효성 검사(값을 검증하는 것)에서 활용

  - DateTimeField
    - `auto_now_add=True` : 최초 생성일자
    - `auto_now=True`: 최종 수정일자

- 명령어

  - `sqlmigrate`: 해당 migrations 설계도가 SQL 문으로 어떻게 해석되어서 동작할지 미리 확인 할 수 있다.

  - `showmigrations`: migrations 설계도들이 migrate 됐는지 안됐는지 여부를 확인 할 수 있다.

  - `migrate`

    - 설계도를 실제 DB에 반영하는 과정

    - `migrate` 는 `makemigrations` 로 만든 설계도를 실제 `db.sqlite3` DB에 반영한다.

  - `makemigrations`
    - 모델을 변경한 것에 기반한 새로운 마이그레이션을 만들 때 사용
    - 모델을 활성화 하기 전에 DB 설계도(마이그레이션) 작성



---

## CRUD

```python
# crud/settings.py

'DIRS': [BASE_DIR / 'crud' / 'templates'],
```

```python
# articles/urls.py

from django.urls import path
from . import views

app_name = 'articles'
urlpatterns = [
    path('', views.index, name='index'),
]



# articles/views.py

def index(request):
    return render(request, 'articles/index.html')
```

- GET

  ```PYTHON
   article = get_object_or_404(Article, pk=pk)
  ```

  

- 게시글 순서변경

  ```python
  # articles/views.py
  
  def index(request):
      # 1. articles = Article.objects.all()[::-1]	 # 파이썬이 변경
      # 2. articles = Artile.objects.order_by('-pk')  # DB에서 변경
  ```

  

- `csrf token`
  - 사이트 간 요청 위조(Cross-Site-Request-Fogery)

    - 웹 애플리케이션 취약점 중 하나로 **사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 하여 특정 웹페이지를 보안에 취약하게 한다거나 수정, 삭제 등의 작업을 하게 만드는 공격 방법**을 의미한다.
    - `{% csrf_token %}` 을 설정하면 input type hidden 으로 특정한 hash 값이 들어있다.

  - `{% csrf_token %}` 이 없다면?

    - `403 forbidden` 에러: 서버에 요청은 도달했으나 서버가 접근을 거부할 때 반환하는 HTTP 응답 코드 / 오류 코드. 서버 자체 또는 서버에 있는 파일에 접근할 권한이 없을 경우에 발생
    - 이러한 접근을 할 수 있도록 하는 것이 `{% csrf_token %}` → 사내 인트라넷 서버를 사내가 아닌 밖에서 접속하려고 할 때도 해당 HTTP 응답 코드가 뜬다.

  - 해당 csrf attack 보안과 관련된 설정은 `settings.py`에서 `MIDDLEWARE` 에 되어있음

    - 실제로 요청 과정에서 `urls.py` 이전에 Middleware의 설정 사항들을 순차적으로 거친다. 응답은 아래에서 위로부터 미들웨어를 적용시킨다.

- Redirect

  POST 요청은 HTML 문서를 렌더링 하는 것이 아니라 **'~~ 좀 처리해줘(요청)'의 의미이기 때문에 요청을 처리하고 나서의 요청의 결과를 보기 위한 페이지로 바로 넘겨주는 것이 일반적**이다.

- humanize

  naturaltime, naturalday

---

## Forms

## Django's role in forms

Django는 forms에 관련된 작업의 세 부분을 처리한다.

1. 렌더링을 위한 데이터 준비 및 재구성
2. 데이터에 대한 HTML forms 생성
3. 클라이언트로 부터 받은 데이터 수신 및 처리
4. `Form` 클래스는 Django form 관리 시스템의 핵심이다. Form 클래스는 form내 field들, field 배치, 디스플레이 widget, label, 초기값, 유효한 값과 (유효성 체크이후에) 비유효 field에 관련된 에러메시지를 결정한다.

이 모든 작업을 수동으로 수행하는 코드를 작성할 수 있지만 Django가 모든 작업을 처리 할 수 있다.

- Outputting forms as HTML
  - `as_p()` : 각 필드가 단락(paragraph)으로 렌더링
  - `as_ul()` : 각 필드가 목록항목(list item)으로 렌더링
  - `as_table()` : 각 필드가 테이블 행으로 렌더링　





