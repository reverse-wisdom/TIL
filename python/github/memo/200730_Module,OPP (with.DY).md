> ## **Module**

- 모듈: 특정 기능을 하는 변수, 함수, 클레스 코드를 .py나 스트립트 단위로 작성

- 패키지: 특정 기능과 관련된 여러 모듈의 집합. 패키지는 또 다른 서브 패키즈를 가질 수있음.

- 라이브러리: 모듈과 패키지들의 집합(파이썬 표준 라이브러리 PSL)

- 패키지 관리자: 외부 패키지(PyPI에 등록된 패키지)를 설치할 수 있게 도와주는 패키지(pip)

  [참조][(https://pypi.org/)]

  > ### **모듈의 활용**

  -  `import` 를 통해서 모듈을 이름 공간으로 가져와야한다.
  - `import` 모듈명
  - `from` 모듈명 `import` 변수, 함수, 클래스
  - `from` 모듈명 `import`

  > ### **패키지의활용**

  - 점(.)으로 구분된 모듈 이름(패키지명.모듈명)을 써서 모듈을 구조화하는 방법
  - `from` 패키지명 `import` 모듈명
    - 모듈명.변수명, 모듈명.함수명, 모듈명.클래스명
  - `from` 패키지명 `import` `as` 별명
    - 별명.변수명, 별명.함수명, 별명.클래스명

  - `from` 패키지명.모듈명 `import` 변수명, 함수명, 클래스명

    - 변수명, 함수명, 클래스명

  - `from` 패키지명. 모듈명 `import` * 

    - 메모리 많이 잡아먹으면 가급적이면 사용x

    

  ```python
  #1
  import datetime #모듈명 datetime
  print(datetime.datetime.now())  #now:datetime 클래스 안에 있는 메소드
  ```

  

  ```python
  #2
  from datetime import datetime
  print(datetime.now())
  ```

  ```python
  #3 Module Erro
  from datetime.datetime import now #메서드(now)는 불러올수 없음
  ```

  

  >### **모듈을 찾는 순서**

   1. 실행하는 파일의 경로에서 import 하는 모듈을 검색

   2. 파이썬에서 제공하는 라이브러리(.py)에서 모듈을 검색

   3. 외부 패키지에서 모듈을 검색

      

> ## **OOP**

- 객체: 같은 종류의 집합을 모아놓은 집합체, 즉 속성(설명 가능한 무엇)과 행동 요소(행동)를 가지는것

- Class: 객체를 표현하는 문법, 설계도

  - 파이썬으로 클래스를 표한할 때는 파스칼 케이스를 클래스명으로 사용함.

    (함수와 구분하기 위해서 사용)

  ```python
  class ClassName:
      <attributes>
  	<methods>
  ```

- 인스턴스: 클래스로부터 생성한 개별대상.
  - 자신의 속성을 가질 수 있다.
  - 클래스에서 정의한 속성이나 행위(methods)를 수행할 수 있다.

- 속성: 클래스, 인스턴스에서 가지는 데이터

- 메서드: 클래스, 인스턴스가 할 수있는 행위

- **생성자**: 인스턴스 객체가 생성될때 호출되는 함수.

  ``` python
  class ClassName:
      def __init__(self):
          print('생성될 때 자동으로 호출되는 생성자')
          
  ```

  

- **소멸자**: 인스턴스 객체가 삭제될 때 호출되는 함수

  ```python
  class ClassName:
      def__del__(self):
      	print('삭제될때 잦동으로 호출되는 소멸자')
  ```

  

- **`self`**: 인스턴스 자기자신
  - 파이썬에서 메서드가 호출될 때 인자로 인스턴스 잣니이 알아서 전달됨.



### **인스턴스 변수/ 클래스 변수**

- 인스턴스 변수
  - 각 인스턴스의 고유한 변수
  - 생서자에서 `self`.`변수명` 으로 정의
  - 인스턴스가 생성이 되면 `인스턴스명.변수명` 으로 접근 및 할당 가능.

- 클래스 변수
  - 클래스가 가지고 있는 변수이며 모든 인스턴스가 공유
  - 클래스 선언 내부에서 정의
  - 클래스가 생성되면 `클래스명. 변수명` 또는 `인스턴스명. 변수명` 으로 접근 및 할당가능

- 이름 공간 탐색
  - 클래스를 생성하면 동시에 클래스의 이름공간이 생성됨.
  - 인스턴스를 만들면 인스턴스 객체가 이름 공간에서 생성됨
  - 인스턴스 변수가 변경되면, 변경된 데이터는 인스턴스 객체 이름공간에 저장함.
  - 탐색순서: **인스턴스 이름공간-> 클래스 이름공간-> 글로벌 이름공간**

### **인스턴스 메서드/클래스 메서드(스태틱 메서드)**

- **인스턴스 메서드**
  - 인스턴스가 사용하는 메서드
  - 클래스 내부에 정의되는 메서드는 기본적으로 인스턴스 메서드가 된다.
  - 호출시, 첫번쨰 인자로 인스턴스 자기자신이 self로 전달됨

- **클래스 메서드**
  - 클래스가 사용하는 메서드
  - 클래스 내부 변수에 접근할 때 주로 사용.
  - 클래스 메서드를 정의할때 `@classmethod` 이라는 데코레이터를 사용해서 정의
  - 호출시, 첫번째 인자로 클래스를 `cls` 에 전달됨.

- **스태틱 메서드**
  - 클래스가 사용하는 메서드
  - 스태틱 메서드를 정의할때 `@staticmethod` 라는 데코레이터를 사용해서 정의
  - 호출시 어떠한 인자도 전달되지 않음.



### **비교정리**

- 인스턴스는 3가지 메서드에 모두 접근할 수 있다.

  - 인스턴스는 인스턴스 메서드만 호출해야한다.

  - 그래서 인스턴스가 할 행동은 모두 인스턴스 메서드로 한정지어서 설계한다.

- 클래스도 3가지 메서드에 모두 접근할 수 있다.

  - 클래스도 인스턴스 메서드는 호출하지 않는다. (가능하다 != 사용한다)
  - 클래스가 할 행동은 다음 원칙에 따라 설계
    - 클래스 자체(`cls`)와 그 속성에 접근할 필요가 있다면 **클래스 메서드**로 정의
    - 클래스나 클래스 속성에 접근할 필요가 없다면 **스태틱 메서드**로 정의

  > ### **상속**

  - 부모 클래스의 모든 속성이 자식 클래스에게 상속해서 코드의 재사용이 높아짐.

    ```python
    class ChildClass(ParentClass): #함수혼동x 파스칼케이스로 구분
    	<code block>
        
    ```

    - 이처럼 공통된 속성이나 메서드를 부모 클래스에 정의하고 이를 상속받아서 다양한 자식 클래스를 생성 할 수있다.

  - 클래스 상속 검사

    ```python
    #상속 관계 여부를 확인하는 내장 함수
    issubclass(자식클래스, 부모클래스) #is 가 붙으면 True아니면 False로 반환
    
    #인스턴스 인지 여부를 확인하는 내장함수
    isinstance(인스탄스명, 클래스)
    ```

    

  - super()

    - 자식클래스에서 부모클래스 메서드를 사용하고자 할 때
    - super는 자식 클래스의 부모 클래스를 위미

    ```python
    class ChildClass(ParentClass):
        def method(self, arg):
            super().method(arg)
            
    ```

  - 메소드 오버라이딩

    - 자식 클래스에서 부모클래스의 메서드를 재정의 하는 것.

  - 상속 관계에서의 이름공간

    - 인스턴스=>클래스=> 전역
    - 인스턴스=>자식클래스=> 부모클래스=> 전역

  - 다중상속
    - 두개 이상의 클래스를 상속 받는 경우
    - 상속 순서가 중요(**왼쪽->오른쪽**)

